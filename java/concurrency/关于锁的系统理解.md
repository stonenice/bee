## 锁与相关概念
锁是用来控制多个线程访问共享资源的方式。
### 死锁(Deadlock)与活锁(Livelock)
死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。

产生死锁的原因：
- 因为系统资源不足。
- 进程推进的顺序不当。
- 资源分配不当。(银行家算法)

死锁的条件：
- **互斥条件** 一个资源每次只能被一个进程使用。
- **请求并保持条件** 一个进程因请求资源而阻塞时，对已获得的资源保持不放。
- **不剥夺条件** 进程已获得的资源，在末使用完之前，不能强行剥夺。
- **循环等待条件** 若干进程之间形成一种头尾相接的循环等待资源关系。

活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试—失败—尝试—失败的过程。处于活锁的实体是在不断的改变状态，
活锁有可能自行解开。

死锁和活锁的本质是一样的，线程的任务都无法向前推进，原因都是是在获取临界区资源时，并发多个进程/线程声明资源占用(加锁)的顺序不当。
两者的区别是，死锁在加不上锁时死等并且不释放已持有的锁，线程的状态是阻塞。活锁在加不上锁时会释放已持有的资源并一直重试，线程的状态是运行。
可以用mutex.lock()和mutex.tryLock()帮助理解。

### 悲观锁和乐观锁
悲观锁是指悲观的认为共享资源一定别其它线程修改，因此为了保证对共享资源的正确访问，先对资源加锁再进后续操作。在资源竞争不严重时悲观锁的性能
有待提升。
乐观锁是指乐观的认为共享资源没有被其它线程占用，因此直接对数据进行修改，如果其它线程正在占用着资源导致修改失败，那么线程会多次进行尝试。乐观
锁不能算是一种锁，而是一种冲突检查机制，并发性能好。一般多采用版本号的机制实现。JAVA中的CAS算法也是一种乐观锁的体现。

## 锁的优化原则
>锁的竞争必然会导致程序的整体性能下降，为了降低这种副作用，遵循以下锁优化原则能够减轻锁竞争带来的性能下降。
- **减小锁持有时间** 在锁竞争过程中，单个线程对锁的持有时间的长短会直接影响锁竞争的激烈程度。减少锁持有的时间有助于降低锁冲突的可能性，进而提升
系统的并发能力。 一种有效的方法是仅对临界资源加锁，其它操作不要放到临界区内。
- **减小锁粒度** 减小锁粒度也是一种削弱多线程竞争的有效手段，典型的场景为数据库中的表锁与行锁，ConcurrentHashMap中的分段锁技术。但减小锁的粒度
会带来获取全局锁时对资源的性能消耗。因此这中方法只有在获取全局信息不频繁是才能真正意义上提高系统吞吐量。
- **读写分离锁来替换独占锁** 相较减小锁粒度是通过分割数据结构来实现，那么读写锁是通过分割业务逻辑来实现性能的提升。具体就是多读单写，写会阻塞读
以防止读到脏数据，读可以多线程并发的读。 在读多写少的场景下，读写锁能有效的提升系统的并发能力。
- **锁分离** 锁分离是对读写锁的进一步延伸，它可以将独占锁进行分离。比如队列的出队和入读可以将或去单个锁改造成获取入队和出队锁减少锁冲突。
- **锁粗化** 如果遇到一连续对同一锁不断进行加解锁时，把对锁的多次操作合成一次操作，从而减少对锁的请求同步次数，这个操作叫做锁粗化。比如在循环内
请求锁时，便可以优化成在循环外加锁。 **锁粗化和减少锁粒度是相互矛盾的，需要根据实际情况进行取舍**

## JAVA中的锁
在我的理解看来，JAVA中的锁只有显式锁(Lock)和隐式锁(synchronized)两种.这里的显式与隐式是指获取锁与释放锁的过程是否需要在代码中明确声明处来.
Lock底层是依赖AQS实现，可以根据自己的要求利用AQS实现特定场景下的高性能。而synchronized的高性能是通过JVM去优化的，具体是通过偏向锁到达可重
入锁的效果，利用轻量级锁到达CAS无锁并发的效果(现在自旋不阻塞，占用CPU)，重量级锁(阻塞线程，不占用CPU)就是会阻塞线程的普通锁。因此可以认为
偏向锁、轻量级锁、重量级锁是JVM对synchronized，在不同锁竞争下的优化。

### 隐式锁(synchronized)
JVM对synchronized的优化：
- **偏向锁** 等同于可重入锁。
- **轻量级锁** CAS算法修改对象头MarkWord,成功则加锁成功，失败则膨胀为重量级锁，一种乐观锁的体现。
- **自旋锁** 当轻量级锁膨胀后，JVM不会直接阻塞线程升级成重量级锁。JVM会做几次CAS尝试，如果都加锁失败才会真正在系统层面挂起该线程，升级为重量级锁。
- **锁消除** 锁消除是一种更彻底的锁优化，在JIT编译时，通过对运行上下文的扫描，去除不可能存在资源竞争的锁，来节省请求锁的时间。锁消除涉及到逃逸
分析技术，逃逸分析就是观察某个变量是否会套出某一个作用域。

### 显式锁(Lock)
显示锁是对JAVA实现Lock接口的锁的统称。Lock接口统一定义了一些锁的操作，JDK中对该接口的实现主要有ReentrantLock, StampedLock, 
ReentrantReadWriteLock. 以上这锁的实现都是基于AQS实现的。

#### 同步队列器AQS(AbstractQueuedSynchronizer)
##### 公平与非公平
##### 独占和共享
##### 条件变量(Condition)

#### 重入锁(ReentrantLock)
#### 悲观读写锁(ReentrantReadWriteLock)
#### 乐观读写锁(StampedLock)
