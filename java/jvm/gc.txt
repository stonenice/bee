1.如何判断对象需要被回收：引用计数算法、可达性分析算法

引用计数算法：
给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1.任何时刻对象的计数器为0时，
对象就不可能再被使用。但该算法的缺点是很难解决对象之间相互循环引用的问题。

可达性分析算法：
以被称为GC Roots的对象作为根结点，从这些节点开始向下搜索，搜索所走过的路劲称为引用链，当一个对象不可达时就证明对象不可用，
即该对象不再任何引用链上。
在Java中可作为GC Roots的对象有以下四种：1）虚拟机栈（栈帧中的本地变量表）中引用的对象。2）方法区中静态属性应用的对象。
3）方法区中常量应用的对象。4）本地方法栈中JNI（Native方法）应用的对象。


2.Java中引用的四种类型：强引用(Strong Reference)，软引用(Soft Reference)，弱引用(Weak Reference)，幽灵引用(Phantom Reference).
强引用(Strong Reference):
强引用即为Java中普通的将对象实例赋给另一个变量、另一对象的属于或方法的内部变量。其特点是只要该引用还存在，垃圾收集器则永远
不会回收该对象。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来
解决内存不足的问题。
软引用(Soft Reference)：
软引用是用来描述一些还有用但并非必需的对象，例如缓存的数据对象。如果内存空间不足了既将要发生内存溢出之前，会将这些软引用对象
列进需要回收的范围之内以便进行第二次回收。如果回收完软引用后还是内存不足，才会抛出内存溢出异常。在JDK1.2之后利用SoftReference
类来实现软引用.
弱引用(Weak Reference):
弱引用用来描述非必需对象，强度比软引用更弱，只具有弱引用的对象拥有更短暂的生命周期.被弱引用关联的对象只能生存到下一次垃圾收
集之前。当垃圾收集器工作时，无论内存是否充足，都会回收掉只被弱引用关联的对象。由于垃圾回收器是一个优先级很低的线程，因此不
一定会很快发现那些只具有弱引用的对象。在JDK1.2之后利用WeakReference类来实现软引用.
幽灵引用(Phantom Reference)：
幽灵引用是强度最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用来获取一个对象
的实例。为一个对象设置幽灵引用的唯一目的就是在这个对象被收集器回收时收到一个系统通知，既虚引用主要用来跟踪对象被垃圾回收器
回收的活动如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。程序可以通过判断引用队列
中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引
用的对象的内存被回收之前采取必要的行动。在JDK1.2之后利用PhantomReference类来实现软引用.

3.GC回收策略
-------------------------------------------------------------------------------------------------------------------
-               GC Roots                                                                                          -
-                                                                         |将对象插入F-Queue队列完成第一标记，|   -
-               可达性分析 - - - - - - - - - - - - - - - - - - -- - - ----|JVM自动自动创建低优先级线程执行对  |   -
- （对象是否在以GC Roots为根结点的引用链上）    对象的finalize()没有执行  |象的finalize()方法                 |   -
-                  |                            过或finalize()方法被重载                   |                      -
-                  |                                                                       |                      -
-                  |对象的finalize()执行过或                                 |在第二次标记之前对象被重新引用|     -
-                  |finalize()方法没有被重载                                 |将对象移除F-Queue队列         |     -
-                  |                                                                       |                      -
-              |第一次标记|                                                                |                      -
-                  |                                                                       |                      -
-                  |                                                                       |                      -
-              |第二次标记| ---------------------------------------------------------------|                      -
-                  |                                                                                              -
-                  |                                                                                              -
-                  |                                                                                              -
-                  |----------------|执行回收算法，完成垃圾回收|                                                  -
-------------------------------------------------------------------------------------------------------------------
第一步，执行可达性分析算法，找出系统中无效的对象。
第二步，在所有无效对象中进行分类，筛选的条件是对象是否需要执行finalize()方法（Java中的析构函数）。若需要执行析构函数则将该
对象插入到F-Queue队列，等待执行析构函数并且第一次标记完成。若不需要则完成第一次标记。
第三步，对完成第一次标记的对象进行第二次标记，对于F-Queue队列中的对象也会进行第二次标记，如在第第二次标记之间被重新引用，则
会将该对象移除队列完成第一次救赎。但由于finalize()方法只会执行一次，所以发生救赎的次数只会有一次（分析：回收第二步会进行筛选
，所以执行过finalize()方法的对象不会进入F-Queue队列，所以不存在被重新引用的可能）。
第四步，执行回收算法，完成对象的收集。

4.方法区回收
方法区在HotSpot虚拟机中又叫永久代(Tenured Generation), 永久代的垃圾回收只要为两个部分：废弃的常量和无用的类。
废弃的常量就是没有任何String对象，类，接口，方法，字段的符号引用了常量池中的常量，则GC会回收该废弃的常量。
无用的类必须同时满足以下三个条件才能算是无用的类，且无用的类并不是一定会被回收:
1)该类的所有实例都已经被回收。
2）加载该类的ClassLoader已被回收。
3）该类对应的java.lang.Class对象没有在任何地方被引用，既无法再任何地方通过反射访问到该类的方法。
在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景就需要回收方法区，已保证
永久代不会溢出。

5.垃圾收集算法
标记-清除算法：
标记-清除(Mark-Sweep)算法分为标记和清除两个步骤，首先需要标记出需要回收的所有对象，标记完收统一进行回收。最后就是将标记
的所有对象进行统一的清除，完成垃圾的回收。该算法的缺点主要有两个：一个是标记和清除两个过程的效率都不高，另一个是回收后
会产生大量不连续的内存碎片，空间碎片太多后会在程序运行过程中为大对象分配内存时，由于无法找到足够的连续内存提前触发另一次
垃圾收集过程。
复制算法：
------------------------------------------
-       GC Roots    |                    -
-          |        |                    -
-         obj1      |                    -
-          |        |                    -
-   obj3  obj2      |                    -
-    |     |        |                    -
-   obj4<--|        |                    -
-                   |                    -
-    Woking Area    |    Free Area       -
------------------------------------------
              回收之前
------------------------------------------
-                   |       GC roots     -
-                   |         |          -
-                   |        obj1        -
-                   |         |          -
-   obj3            |        obj2        -
-    |              |                    -
-   obj4            |                    -
-                   |                    -
-    Free Area      |    Working Area    -
------------------------------------------
               回收之后
复制算法的原理为将整个内存分为工作区和空闲区两块，回收时将工作区的所有存活对象有序的全部复制到空闲区，此时之前的工作区
变成现在的空闲区，之前的空闲区变成现在的工作区。最后在把之前的工作区一次性全部清除并回收。因此收集后不会产生内存碎片，只要
移动堆顶指针，按照顺序分配内存即可，实现简单，运行效率高。缺点是可用内存变成之前的一半，内存利用率低。如果对象的存活率很
高，最坏的情况是对象全部都存活（存活率为100%），那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所
花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。
标记-整理算法：
标记-整理（Mark-Compact）算法与标记-清除算法类似，主要用于老年代的垃圾回收。算法的原理是首先对无效对象进行
标记以完成第一步标记过程。第二步整理过程的整理操作是将所有存活对象移到一端，然后直接清理掉端边界以外的内存。
分代收集算法:
分代收集（Generation Collection）算法并没有新的算法思想，只是根据对象的存活时间的不同将内存划分为不同的块。JVM根据不同
的内存块使用不同的回收算法，例如对于存活率较低的新生代就使用复制算法，对于存活率高的老年代就可以使用标记-整理算法或者
标记-清除算法。

6.HotSpot可达性分析算法的实现（OopMap,安全点(Safe Point)，安全区域(Safe Region)）
可作为GC roots的节点主要在全区性的引用上（常量或类静态属性）和执行上下文（栈帧中的本地变量表）中。可达性分析必须在对象
引用关系不变的情况下进行，否则分析结果的准确性就无法得到保证。在进行GC收集时必须停顿所有Java线程的现象叫做Stop The World.
为了能缩短执行可达性分析而出现停顿的时间，HotSpot的实现中使用了OopMap的数据结构来记录每个对象内什么偏移量上是什么类型，
也会记录栈和寄存器中哪些位置是引用。这样，GC在枚举GC Roots时就能快速准确的完成分析，标记处无用的对象。
程序中具有使程序出现长时间执行的特征的地方就叫做安全点，长时间执行最明显的特征就是指令序列复用，例如方法调用，循环跳转，
异常跳转等指令。所以具有这些功能的指令才会产生Safepoint.
安全区域是引用关系不会发生变化的一段代码片段，也可把安全区域看做是被扩展了的安全点。

由上面的OopMap（普通对象指针数组），安全点(Safe Point)和安全区域(Safe Region)等概念，可知道HotSpot在实现可达性分析算法的
实现过程如下。首先在程序出现安全点与安全区的时候将对象之间的引用关系记录在OopMap中，最后通过分析OopMap完成可达性分析。为
什么会分析OopMap而不直接分析虚拟机栈中的GC Roots是因为前者执行效率更高。判断可达可以使用DFS（深度优先）算法。




