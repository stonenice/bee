1.如何判断对象需要被回收：引用计数算法、可达性分析算法

引用计数算法：
给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1.任何时刻对象的计数器为0时，
对象就不可能再被使用。但该算法的缺点是很难解决对象之间相互循环引用的问题。

可达性分析算法：
以被称为GC Roots的对象作为根结点，从这些节点开始向下搜索，搜索所走过的路劲称为引用链，当一个对象不可达时就证明对象不可用，
即该对象不再任何引用链上。
在Java中可作为GC Roots的对象有以下四种：1）虚拟机栈（栈帧中的本地变量表）中引用的对象。2）方法区中静态属性应用的对象。
3）方法区中常量应用的对象。4）本地方法栈中JNI（Native方法）应用的对象。


2.Java中引用的四种类型：强引用(Strong Reference)，软引用(Soft Reference)，弱引用(Weak Reference)，幽灵引用(Phantom Reference).
强引用(Strong Reference):
强引用即为Java中普通的将对象实例赋给另一个变量、另一对象的属于或方法的内部变量。其特点是只要该引用还存在，垃圾收集器则永远
不会回收该对象。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来
解决内存不足的问题。
软引用(Soft Reference)：
软引用是用来描述一些还有用但并非必需的对象，例如缓存的数据对象。如果内存空间不足了既将要发生内存溢出之前，会将这些软引用对象
列进需要回收的范围之内以便进行第二次回收。如果回收完软引用后还是内存不足，才会抛出内存溢出异常。在JDK1.2之后利用SoftReference
类来实现软引用.
弱引用(Weak Reference):
弱引用用来描述非必需对象，强度比软引用更弱，只具有弱引用的对象拥有更短暂的生命周期.被弱引用关联的对象只能生存到下一次垃圾收
集之前。当垃圾收集器工作时，无论内存是否充足，都会回收掉只被弱引用关联的对象。由于垃圾回收器是一个优先级很低的线程，因此不
一定会很快发现那些只具有弱引用的对象。在JDK1.2之后利用WeakReference类来实现软引用.
幽灵引用(Phantom Reference)：
幽灵引用是强度最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用来获取一个对象
的实例。为一个对象设置幽灵引用的唯一目的就是在这个对象被收集器回收时收到一个系统通知，既虚引用主要用来跟踪对象被垃圾回收器
回收的活动如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。程序可以通过判断引用队列
中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引
用的对象的内存被回收之前采取必要的行动。在JDK1.2之后利用PhantomReference类来实现软引用.

3.GC回收策略
-------------------------------------------------------------------------------------------------------------------
-               GC Roots                                                                                          -
-                                                                         |将对象插入F-Queue队列完成第一标记，|   -
-               可达性分析 - - - - - - - - - - - - - - - - - - -- - - ----|JVM自动自动创建低优先级线程执行对  |   -
- （对象是否在以GC Roots为根结点的引用链上）    对象的finalize()没有执行  |象的finalize()方法                 |   -
-                  |                            过或finalize()方法被重载                   |                      -
-                  |                                                                       |                      -
-                  |对象的finalize()执行过或                                 |在第二次标记之前对象被重新引用|     -
-                  |finalize()方法没有被重载                                 |将对象移除F-Queue队列         |     -
-                  |                                                                       |                      -
-              |第一次标记|                                                                |                      -
-                  |                                                                       |                      -
-                  |                                                                       |                      -
-              |第二次标记| ---------------------------------------------------------------|                      -
-                  |                                                                                              -
-                  |                                                                                              -
-                  |                                                                                              -
-                  |----------------|执行回收算法，完成垃圾回收|                                                  -
-------------------------------------------------------------------------------------------------------------------
第一步，执行可达性分析算法，找出系统中无效的对象。
第二步，在所有无效对象中进行分类，筛选的条件是对象是否需要执行finalize()方法（Java中的析构函数）。若需要执行析构函数则将该
对象插入到F-Queue队列，等待执行析构函数并且第一次标记完成。若不需要则完成第一次标记。
第三步，对完成第一次标记的对象进行第二次标记，对于F-Queue队列中的对象也会进行第二次标记，如在第第二次标记之间被重新引用，则
会将该对象移除队列完成第一次救赎。但由于finalize()方法只会执行一次，所以发生救赎的次数只会有一次（分析：回收第二步会进行筛选
，所以执行过finalize()方法的对象不会进入F-Queue队列，所以不存在被重新引用的可能）。
第四步，执行回收算法，完成对象的收集。

4.方法区回收
方法区在HotSpot虚拟机中又叫永久代(Tenured Generation), 永久代的垃圾回收只要为两个部分：废弃的常量和无用的类。
废弃的常量就是没有任何String对象，类，接口，方法，字段的符号引用了常量池中的常量，则GC会回收该废弃的常量。
无用的类必须同时满足以下三个条件才能算是无用的类，且无用的类并不是一定会被回收:
1)该类的所有实例都已经被回收。
2）加载该类的ClassLoader已被回收。
3）该类对应的java.lang.Class对象没有在任何地方被引用，既无法再任何地方通过反射访问到该类的方法。
在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGI这类频繁自定义ClassLoader的场景就需要回收方法区，已保证
永久代不会溢出。

5.垃圾收集算法
标记-清除算法：
标记-清除(Mark-Sweep)算法分为标记和清除两个步骤，首先需要标记出需要回收的所有对象，标记完收统一进行回收。最后就是将标记
的所有对象进行统一的清除，完成垃圾的回收。该算法的缺点主要有两个：一个是标记和清除两个过程的效率都不高，另一个是回收后
会产生大量不连续的内存碎片，空间碎片太多后会在程序运行过程中为大对象分配内存时，由于无法找到足够的连续内存提前触发另一次
垃圾收集过程。
复制算法：
------------------------------------------
-       GC Roots    |                    -
-          |        |                    -
-         obj1      |                    -
-          |        |                    -
-   obj3  obj2      |                    -
-    |     |        |                    -
-   obj4<--|        |                    -
-                   |                    -
-    Woking Area    |    Free Area       -
------------------------------------------
              回收之前
------------------------------------------
-                   |       GC roots     -
-                   |         |          -
-                   |        obj1        -
-                   |         |          -
-   obj3            |        obj2        -
-    |              |                    -
-   obj4            |                    -
-                   |                    -
-    Free Area      |    Working Area    -
------------------------------------------
               回收之后
复制算法的原理为将整个内存分为工作区和空闲区两块，回收时将工作区的所有存活对象有序的全部复制到空闲区，此时之前的工作区
变成现在的空闲区，之前的空闲区变成现在的工作区。最后在把之前的工作区一次性全部清除并回收。因此收集后不会产生内存碎片，只要
移动堆顶指针，按照顺序分配内存即可，实现简单，运行效率高。缺点是可用内存变成之前的一半，内存利用率低。如果对象的存活率很
高，最坏的情况是对象全部都存活（存活率为100%），那么我们需要将所有对象都复制一遍，并将所有引用地址重置一遍。复制这一工作所
花费的时间，在对象存活率达到一定程度时，将会变的不可忽视。
标记-整理算法：
标记-整理（Mark-Compact）算法与标记-清除算法类似，主要用于老年代的垃圾回收。算法的原理是首先对无效对象进行
标记以完成第一步标记过程。第二步整理过程的整理操作是将所有存活对象移到一端，然后直接清理掉端边界以外的内存。
分代收集算法:
分代收集（Generation Collection）算法并没有新的算法思想，只是根据对象的存活时间的不同将内存划分为不同的块。JVM根据不同
的内存块使用不同的回收算法，例如对于存活率较低的新生代就使用复制算法，对于存活率高的老年代就可以使用标记-整理算法或者
标记-清除算法。

6.HotSpot可达性分析算法的实现（OopMap,安全点(Safe Point)，安全区域(Safe Region)）
可作为GC roots的节点主要在全区性的引用上（常量或类静态属性）和执行上下文（栈帧中的本地变量表）中。可达性分析必须在对象
引用关系不变的情况下进行，否则分析结果的准确性就无法得到保证。在进行GC收集时必须停顿所有Java线程的现象叫做Stop The World.
为了能缩短执行可达性分析而出现停顿的时间，HotSpot的实现中使用了OopMap的数据结构来记录每个对象内什么偏移量上是什么类型，
也会记录栈和寄存器中哪些位置是引用。这样，GC在枚举GC Roots时就能快速准确的完成分析，标记处无用的对象。
程序中具有使程序出现长时间执行的特征的地方就叫做安全点，长时间执行最明显的特征就是指令序列复用，例如方法调用，循环跳转，
异常跳转等指令。所以具有这些功能的指令才会产生Safepoint.
安全区域是引用关系不会发生变化的一段代码片段，也可把安全区域看做是被扩展了的安全点。

由上面的OopMap（普通对象指针数组），安全点(Safe Point)和安全区域(Safe Region)等概念，可知道HotSpot在实现可达性分析算法的
实现过程如下。首先在程序出现安全点与安全区的时候将对象之间的引用关系记录在OopMap中，最后通过分析OopMap完成可达性分析。为
什么会分析OopMap而不直接分析虚拟机栈中的GC Roots是因为前者执行效率更高。判断可达可以使用DFS（深度优先）算法。

7.垃圾收集器
JVM中包含的垃圾收集器按代划分可以分为以下两类,除此之外还包括不区分代的G1(Garbage-First).
新生代(Young Generation):Serial, ParNew, Parallel Scavenge(ps).
老年代(Tenured Generation):Serial Old(MSC), CMS, Parallel Old.

注意:在垃圾回收中的并行和并发与并发编程中的概念不是一个意思，垃圾收集中的并发与并行的区别就是用户线程是否暂停具体如下：
垃圾收集中的并行(Parallel)是指用户线程暂停的状态下多个垃圾收集线程并行工作(单CPU下GC线程依然是交替执行，多CPU下GC线程
可能是真正意义的并行)。
垃圾收集中的并发(Concurrenct)是指用户线程与一个或多个垃圾收集线程一起执行（单CPU下GC线程与用户线程交替执行，多CPU下GC
线程与用户线程可能并行执行）。

1)Serial收集器
单线程收集器，新生代收集器，采用复制算法，进行垃圾收集时必须暂停其他所有的工作线程，默认client模式下新生代的收集器

2）ParNew收集器
并行多线程收集器并能利用多核CPU，新生代收集器，采用复制算法，进行垃圾收集时必须暂停其他所有的工作线程.ParNew本质上就是
Serial的多线程版本，所以收集算法、STW(Stop The World)、对象分配规则、回收策略等都与Serial一样。ParNew是Server模式下新生
代收集器的首选，主要原因是除了Serial之外，目前能与老年代收集器CMS配合使用的新生代收集器只有ParNew.其次是服务器大部分都
是多核多CPU的配置，使用单线程的Serial不能充分利用CPU资源，而ParNew是多线程的所以能很好使用服务器资源。

3）Parallel Scavenge(ps)收集器
并行多线程收集器并能利用多核CPU, 新生代收集器，采用复制算法，进行垃圾收集时必须暂停其他所有的工作线程。Parallel Scavenge
与ParNew类似,他们的区别在于其他收集器关注的是停顿时间并尽可能的缩短执行GC时用户线程堵塞的时间，而Parallel Scavenge关注的
是JVM的吞吐量（吞吐量=（用户线程执行的时间）/（用户线程执行时间+GC线程执行时间））。还有就是Parallel Scavenge收集器具有
GC自适应的调节策略(GC Ergonomics),JVM根据运行情况动态调节参数以提供最合适的停顿时间或最大的吞吐量。

4）Serial Old(MSC)收集器
单线程收集器，老年代收集器，采用标记-整理算法，进行垃圾收集时必须暂停其他所有的工作线程。主要在client模式下用于老年代
的收集，会使用到Serial Old的途径一是在jdk1.5以及之前的版本中与Parallel Scavenge搭配，因为以前的jdk版本中新生代选用了
Parallel Scavenge那么老年代中就只有Serial Old能与其一起工作。二是作为CMS出现Concurrent Mode Failure时的替代方案。

5）Parrallel Old收集器
并行多线程收集器，老年代收集器，采用标记-整理算法，进行垃圾收集时必须暂停其他所有的工作线程。Parrallel Old主要关注老年代
垃圾收集的吞吐量，因此该收集器用于与新生代ParallelScanvenge收集配合使用，因为在要求吞吐量的服务器上，新生代选用Parallel
Scavenge是最好的选择，但在老年代中只有Serial Old关注的是停顿时间，不能很好的支持吞吐量的要求，所以需要同样关注吞吐量的
Parrallel Old一起配合使用。

6）CMS(Concurrent Mark Sweep)收集器
并发多线程收集器，老年代收集器，采用标记-清除算法，CMS的收集过程分为四步：1）初始标记 2）并发标记 3）重新标记 4）并发清除
其中初始标记与重新标记两个步骤任然需要停顿用户线程(STW),并发标记与并发清除两个步骤耗时最长，但不用停顿用户线程并与其一起
执行，减轻了GC收集对用户线程的影响，提高了响应速度。GC收集与用户线程一起工作延长了GC执行的时间，降低了吞吐量。CMS是
以牺牲吞吐量代价获得最短的GC停顿，因此主要用于重视服务器响应速度，用户交互体验的JVM中。CMS具体每个步骤的作用如下：
1）初始标记
在这个阶段，需要虚拟机停顿所有的用户线程，然后只是标记能与GC Roots[直接关联]的对象.因此虽然需要停顿，但是速度很快影响不大。
2）并发标记
由于初始标记仅仅标记了与GC Roots直接关联的对象，要将堆中所以的垃圾进行标记，还需要在初始标记的基础上继续向下追溯标记。并发
标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。
3）重新标记
这个阶段会暂停虚拟机，修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象。停顿的时间比初始标记稍长，远比并
发标记时间短。
4）并发清除
这个阶段收集器线程和用户线程并发执行，清理垃圾对象。

CMS的优点是并发收集，低停顿.
CMS缺点主要有三方面：1）占用CPU资源导致应用程序变慢，总吞吐量下降（CPU，内存等资源稀缺时影响非常大，因此CMS适合
硬件配置非常好的环境）。2）无法处理浮动垃圾（Floating Garbage）(完成重新标记过后，无法清除继续运行的用户线程产生的垃圾，只
好留到下次处理的垃圾就叫做浮动垃圾),因而可能出现Concurrent Mode Failure失败导致另一次Full GC。3）由于采用标记-清除算法，会
产生大量的内存碎片，往往会出现大量剩余空间但无法分配给需要连续空间的大对象。

7）G1(Garbage First)收集器
并行并发多线程收集器（并发标记，最终标记与筛选回收则是并行执行），整体上基于标记-整理算法局部（两个region之间）上是采用
复制算法。G1收集器与CMS收集器类似也分为四步：1）初始标记 2）并发标记 3）最终标记 4）筛选回收。G1中只有并发标记是与用户
线程一起执行，其他三个步骤都是并行执行即要求停顿用户线程。G1收集器的具体步骤:
1)初始标记
初始标记仅仅是标记一下GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行
时，能在正确可用的Region中创建对象，该阶段需要停顿用户线程，但时间短。
2）并发标记
并发标记阶段是从GC Roots开始对堆（Heap）中的对象进行可达性分析，找出存活的对象，该阶段耗时长，但可于用户线程并发执行。
3）最终标记
G1收集器将堆（Heap）分为多个大小相等、独立的区域(Region)并管理整个堆的内存空间，每个Region中的对象逻辑上分为新生代与
老年代但不是物理上的区分，也就是说G1管理堆空间的基本单位是Region.而不像其他收集器一样将整个堆空间在物理上分为新生代块
与老年代块分别管理。Region中的对象不可只应用到自己Region中的对象，也会引用到其他Region的对象，实际上任意两个Region中
的对象都有肯互相引用。如果需要回收一个Region就需要对该Region中的对象进行可达性分析标记出无用对象，而要进行可达性分析
需要遍历从GC Roots为根的对象引用图，也就可能会扫描整个堆。既然G1管理的基本单位是Region,那么垃圾的标记与整理都只会发生
在Region中而不是整个Java堆中。为了避免出现全堆扫描，G1在每个Region中使用Remembered Set来记录该Region中的对象被那些其他
Region中的对象引用。例如RegionA中的对象rao要引用RegionB中的rbo,在为rao写入rbo的引用时会产生Write Barrier中断写操作，以
便检查rbo的引用是否在RegionA中，很明显rbo在RegionB中与rao不在同一个Region.这时会通过CardTable将rbo的信息记录在RegionA
的Rememberd Set中。这时再Region进行可达性分析时便可根据Remembered Set就能完成。
根据上面的分析可以知道G1是通过Remembered Set实现Region的垃圾标记，由于并发标记过程中用户线程任然在运行，所以标记好后
还是会因为用户线程的运行而发生变化。考虑这点，G1收集器将并发标记这段时间引用关系发生变化的对象记录在Remembered Set Log
中。那么最终标记阶段的功能就是将Remembered Set Log中记录的变化整合同步到Remembered Set中，该阶段需要停顿线程，但是可以
多条GC线程并行执行。补充:由于该阶段是并行标记，因此不会出现像CMS中的浮动垃圾。
4）筛选回收
根据对每个Region回收空间的大小与回收时长等数据计算出回收每个Region的价值并进行排序，选择性优先回收价值大的Region。确保
每次回收时长不超过用户指定的时间。该阶段也需要停顿线程，同样可以多条GC线程并行执行。

G1收集器的主要特点:
1）并发执行，必须停顿的时候也采用并行减少停顿时间。
2）G1以Region的形式管理整个Java堆，没有将堆分为新生代块和老年代块。却在逻辑上将Region中的对象按照生存周期分为新生代对象与
老年代对象。依然使用分代收集的思想。
3）G1整体上基于标记-整理算法，局部上基于复制算法，因此不会像CMS一样产生大量内存碎片。
4）可根据每个Region的回收价值进行选择性回收，确保每次回收时长不超过用户指定的时间。

8.Minor GC和Major GC
Minor GC:Minor GC即为新生代GC,表示对新生代进行了垃圾收集过程。由于新生代对象存活率低，所以Minor GC非常频繁，但速度快。
Major GC/Full GC:Major GC即为老年代GC,表示对老年代进行了垃圾收集过程，通常发生一次Major GC可能发生一次或多次Minor GC，
Major GC一本比Minor GC慢10倍。


