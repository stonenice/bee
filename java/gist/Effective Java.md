## 创建和销毁对象
- 使用静态方法代替多个构造函数,例如JCU中ThreadPool的构造函数很复杂，所有就提供了一个Excutors类提供一系列能一眼看出实际意义的静态方法，
  Excutors.newFixedThreadPool()等。
- 构造函数中参数的个数过多时要考虑用构建器，如OkHttp.newRequstBulder()进行Requset一系列参数设置。解决构造参数过多问题大致有三种方法：
  <br/>1) JavaBean模式，就是用一个DO来进行多参数设置，构造函数就只需要传入一个DO类型即可。不过这种模式阻止了将类做出不可变的特性，有
  线程不安全的风险。<br/>2) 重叠构造函数模式，但是当参数多到一定程度，可读性行和使用上便会出现问题。<br/>3) Builder模式，推荐的方式。
- 在实现单列模式时，可以使用私有构造函数或者枚举类型强化Singlton特性，懒汉式单例模式中所有线程安全的实现有：加valotile的DCL, InnerClass
  延时加载。不过这里推荐使用枚举类的实现方式。
- 避免创建不必要的对象。如String s=new String("Hello"); "Hello"是在栈中创建的实例，又使用new关键字会在堆上又创建一个实例。这样就是多此一举。
  部分情况下这需要执行一次的就不要每次的执行，可以考虑static静态代码块。还有就是避免自动装箱带来的实例创建（Long sum=0L; sum+=1L;）。
- 消除过期引用防止内存泄漏。过期引用是指永远也不会解除的引用，列如ThreadLocal和线程池搭配使用时，虽然放在ThreadLocal中的数据不在使用，
  但是因此线程池的核心线程是一直不会结束的，所有导致与该线程绑定的引用内存一直不能被GC。**顺便提下内存泄漏可以理解为无意识的对象保持。
  内存泄漏常出现在缓存系统中，这内问题中生命周期与时间有关可以采用类似Redis中的过期键删除策略，如果缓存的项的生命周期与外部引用而不是值
  决定时，可以使用WeakReference实现。**
- 避免使用终结方法，因为Finlizer方法不能保证会及时执行，就如System.gc()不保证立即进行对象回收一样。禁止在Finlizer中释放资源而是用Finally.

## 对于所有读写都通用的方法
- 重写eqauls时需要遵守通用约定：自反性、对称性、传递性、一致性、**对于任何非null引用x,x.eqauls(null)必须返回false**.
- 重写eqauls是总是要重写hashCode, 如果不重写对象的hashCode就是Object默认实现（按内存地址进行计算），很容易出现两个对象eqauls相等,而hashCode
  不相等的情况。这时部分使用hash算法的程序就会出现异常情况，比如HashSet就不能确保唯一
- 始终覆盖toString
- 谨慎覆盖clone
- 考虑实现Comparable接口

## 类和接口
- 使类和成员的可访问性最小化
- 在共有类中使用public方法而非public字段
- 使可变性最小化
- 组合模式优于继承
- 要么而为使用继承设计提供文档和说明否则禁止继承 （仅供参考）
- 接口由于抽象类
- 接口只用于定义类型
- 类层次优于使用标签类
- 用函数对象表示策略
- 优先考虑静态成员类

## 泛型
- 不要在新代码中使用原生态类型，这里的原生态类型实在List\<E> == List,Map\<K,V>==Map这里的后者就是原生态类型。
- 消除非受检警告
- 列表优先与数组
- 优先考虑泛型
- 优先考虑泛型方法
- 利用有限统配符来提升API的灵活性，不过需要了解PECS原则，既生产者使用extends,消费者使用super.
- 优先考虑类型安全的异构容器，大概意思是说Java集合框架中的容器都是被参数化了的容器，及一开始指定了容器中元素的类型，该容器就只能存放这
  一种类型的元素。如List就只能放置一种类型的元素，如何是利用Object类型可实现放置多种类型，不过在类型转换时会出现不一致的情况，这就是
  这里所讲的类型不安全。其实可以利用HashMap进行改造，可以将对象的Class<?>作为键，这样统一类型的元素就在一个桶中，数据转化时就能确保安全。

## 枚举和注解
  todo...

## 方法

## 通用程序设计
- 将局部变量的作用域最小化
- for-each优于传统的for

## 异常

## 并发
- 同步访问共享的可变数据
- 避免过度同步
- Executor和Task优于线程
- 并发工具优于wait和notify
- 线程安全性的文档化
- 慎用延迟初始化
- 不要依赖线程调度器
- 避免使用线程组

## 序列化
