1.如何判断对象需要被回收：引用计数算法、可达性分析算法

引用计数算法：
给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器就加1，当引用失效时，计数器就减1.任何时刻对象的计数器为0时，
对象就不可能再被使用。但该算法的缺点是很难解决对象之间相互循环引用的问题。

可达性分析算法：
以被称为GC Roots的对象作为根结点，从这些节点开始向下搜索，搜索所走过的路劲称为引用链，当一个对象不可达时就证明对象不可用，
即该对象不再任何引用链上。
在Java中可作为GC Roots的对象有以下四种：1）虚拟机栈（栈帧中的本地变量表）中引用的对象。2）方法区中静态属性应用的对象。
3）方法区中常量应用的对象。4）本地方法栈中JNI（Native方法）应用的对象。


2.Java中引用的四种类型：强引用(Strong Reference)，软引用(Soft Reference)，弱引用(Weak Reference)，幽灵引用(Phantom Reference).
强引用(Strong Reference):
强引用即为Java中普通的将对象实例赋给另一个变量、另一对象的属于或方法的内部变量。其特点是只要该引用还存在，垃圾收集器则永远
不会回收该对象。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来
解决内存不足的问题。
软引用(Soft Reference)：
软引用是用来描述一些还有用但并非必需的对象，例如缓存的数据对象。如果内存空间不足了既将要发生内存溢出之前，会将这些软引用对象
列进需要回收的范围之内以便进行第二次回收。如果回收完软引用后还是内存不足，才会抛出内存溢出异常。在JDK1.2之后利用SoftReference
类来实现软引用.
弱引用(Weak Reference):
弱引用用来描述非必需对象，强度比软引用更弱，只具有弱引用的对象拥有更短暂的生命周期.被弱引用关联的对象只能生存到下一次垃圾收
集之前。当垃圾收集器工作时，无论内存是否充足，都会回收掉只被弱引用关联的对象。由于垃圾回收器是一个优先级很低的线程，因此不
一定会很快发现那些只具有弱引用的对象。在JDK1.2之后利用WeakReference类来实现软引用.
幽灵引用(Phantom Reference)：
幽灵引用是强度最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生命周期构成影响，也无法通过虚引用来获取一个对象
的实例。为一个对象设置幽灵引用的唯一目的就是在这个对象被收集器回收时收到一个系统通知，既虚引用主要用来跟踪对象被垃圾回收器
回收的活动如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。程序可以通过判断引用队列
中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。如果程序发现某个虚引用已经被加入到引用队列，那么就可以在所引
用的对象的内存被回收之前采取必要的行动。在JDK1.2之后利用PhantomReference类来实现软引用.

3.GC回收策略




