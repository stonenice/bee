自学Python过程中对于理解比较困难的难点

1.*与**的作用
在python中经常会在在函数定义和参数传递时看到*与**, 经过学习可能对于在函数定以的用法能够理解，但在参数传递时确难于理解。
下面我会写出我对这种语法的理解：
1）在函数定义时使用*与**表示函数接受有名和无名的可变参数，可以理解成C语言中的...或PHP中的默认参数。在理解上可以认为将
未定义但在运行时传入的实参存入*表示的形参中，实际上此时的形参就是一个元组（Tuple）。带有键的实参（sex='man'）则存入**
表示的形参中，所有的带键的参数都以字典的形式存入。由上可知，所有可变的参数中不是以键值对传入的参数都可以在*表示的元组
中取得，键值对的参数都能在**表是的字典中取得。具体如下例：

#只能接受定义过的参数，不能接受可变参数，即普通函数
def add(a,b):
    return a+b
    
print add(2,3)   # Right
print add(2,3,4) # Wrong

#能接受多个可变参数，但只能接受无键的参数
def add(a,b,*args):
    if len(args)>0:
        c=a+b
        for x in args:
            c=c+x
        return c
    else:
        return a+b

print add(2,3)   # Right
print add(2,3,4) # Right
print add(2,3,4,mode=False) # Wrong

#能接受有键或无键的可变参数
def add(a,b,*args,**kwargs):
    s=2
    c=a+b
    if len(args)>0:
        for x in args:
            c=c+x
        s=s+len(args)
    if 'mode' in kwargs and kwargs['mode']==True:
        return c/s
    else:
        return c

print add(2,3)   # Right
print add(2,3,4) # Right
print add(2,3,4,mode=True) # Right

2)在参数传递时使用*表示将一个可迭代的对象映射为函数的参数列表，而**则表示将一个可迭代对象映射为函数的有键参数列表。
在python的常见类型中可迭代的类型有字符串，列表，元祖和字典，因此可以将这些类型的变量映射为函数的参数。通常对这个概
念没有理解透彻的人就以为只有这几种类型可以，实际上是只要是可迭代的对象都是可以的，包括自己定义的类，只要你实现的迭
代的接口都可以，以下是例子：

#define user's class which is iteratorable
class myargs:
    def __init__(self):
        self.data=[2,3]
        self.index=0
    def __iter__(self):
        return self
    def next(self):
        if self.index>=len(self.data):
            raise StopIteration
        v=self.data[self.index]
        self.index=self.index+1
        return v
        

arg_str='23'
arg_tuple=(2,3)
arg_list=[2,3]
arg_dict={0:2,1:3}
arg_cls=myargs()



#calculate the sum
#don't accept dict and string
def add(a,b):
    return a+b

print add(2,3) # Right
print add(*arg_str) # Wrong because of character
print add(*arg_tuple) #Right
print add(*arg_list) #Right
print add(*arg_dict) # Wrong
print add(**arg_dict) # Wrong
print add(*arg_cls) # Right

#calculate the sum
#accept anything
def add(a,b,**kwargs):
    c=int(a)+int(b)
    if len(kwargs)>0:
        for k,v in kwargs:
            c=c+int(v)
    return c
    
print add(2,3) # Right
print add(*arg_str) # Right
print add(*arg_tuple) #Right
print add(*arg_list) #Right
print add(*arg_dict) # Right
print add(**arg_dict) # Wrong
print add(*arg_cls) # Right

